
\newpage
\section{Injection SQL }


\subsection{Description}




L'injection SQL, en anglais SQL  injection, ou SQLi en abrégé, est une des attaques les plus dangereuses. Comme pour le Cross Site Scripting présenté dans la suite de ce document, il s'agit ici de tirer parti de l'absence de filtrage des entrées utilisateurs. Cette absence de contrôles permet à un hacker d'insérer du code qui sera interprété par l'analyseur cible, par exemple SQL.




\paragraph{}
Dans la cas particulier de l'injection SQL et du site DVWA, les requêtes SQL, imbriquées dans des scripts PHP qui récupèrent les saisies des utilisateurs, peuvent être détournées sur la base de la syntaxe du langage. 

\begin{figure}[!h]
	\begin{center}
		\includegraphics[scale=1]{images/bd.png}
		\caption{source : \url{https://xkcd.com/327/}}
	\end{center}
\end{figure}


\subsection{Exploitation}

\subsubsection{DVWA - Security level "low"}

La base de données contient 5 utilisateurs identifiés par les entiers de 1 à 5.
La mission proposée par le DVWA est de voler leurs mots de passe par injection SQL.

On règle la "DVWA security" sur low de manière à avoir un site web "damn vulnerable".
On saisit dans le champ User Id, une simple apostrophe i.e. '. Le site retourne le message
"\it {You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near ''''' at line 1}"

\paragraph{}Cette simple apostrophe démontre que le site est vulnérable pour deux raisons : d'abord on sait que nos saisies sont interprétées directement par l'analyseur SQL ; elle ne sont pas filtrées. Ensuite parce que le site est "bavard".

\begin{figure}[!h]
	\begin{center}
		\label{}
		\includegraphics[scale=\scaledvwa]{images/sql/sqli1.png}
		\caption{Les saisies incorrectes donnent lieu à un message d'erreur SQL qui informe le hacker potentiel de l'absence de protection contre les SQLi. D'autres informations importantes sont dévoilées comme le type de base de donnée, ici MariaDB, version libre de MySql rachetée par Oracle.}
	\end{center}
\end{figure}

Un clic sur le bouton "View Source" affiche le code PHP de la page. On constate, en effet, qu'on peut saisir n'importe quoi dans le champ User Id, il sera transmis sans modification à la requête \$query via \$id.   

\begin{figure}[!h]
	\begin{center}
		\label{}
		\includegraphics[scale=0.8]{images/sql/code_low.png}
	\end{center}
\end{figure}



\begin{figure}[!h]
	\begin{center}
		\label{}
		\includegraphics[scale=\scaledvwa]{images/sql/sqli_low.png}
		\caption{Vol des mots de passe par l'injection SQLi sur site non protégé.}
	\end{center}
\end{figure}

L'injection SQL suivante :
{\color{red}

\begin{verbatim}
   ' UNION select password, last_name from users#
\end{verbatim}
}

%  a' UNION SELECT password,last_name from users;-- -&Submit=Submit
% url correspondante 
%  ?id='+UNION+SELECT+password%2Clast_name+from+users%23&Submit=Submit#

donne la requête suivante en remplaçant \$id dans le script PHP :

{\color{red}
\begin{verbatim}
$query  = "SELECT first_name, last_name FROM users WHERE user_id = '' UNION 
           SELECT password, last_name from users#   ';"; 
\end{verbatim}
}
Elle indique donc qu'on effectue l'union au sens mathématique des éléments recueillis par les deux requêtes. Le premier SELECT donne l'ensemble vide, le second donne tous les mots de passe et noms de la table users. On obtient donc les mots de passe faussement associés au champ "First name". Ces mots de passe sont cryptés. On pourra utiliser des techniques de révélation par ingénieurie sociales, recherche internet, force brute, dictionnaires ou rainbow tables. L'outil John the ripper peut entrer en action. On note que Smith est certainement aussi admin car ces deux noms d'utilisateurs ont le même hash donc le même mot de passe. Le hacker peut être confiant quant à la suite des opération car Smith ne semble pas être un adepte de la SSI. Le caractère \# en fin d'injection évite que PHP n'interprête la suite du code en particulier les caractères apostrophes et guillements qui donneraient une erreur SQL.

NB : C'est une technique répandue que de forcer l'analyseur SQL à ignorer le reste de la requête, en utilisant le symbole commentaire SQL double tiret - - les symboles de commentaires PHP dièse \#, {/* */}, {//} pour assurer que ce qui suit l'injection ne sera pas interprété.  



\paragraph{}
Un injection SQL peut aussi donner accès au système de fichier comme le montre l'injection ci-après :
\begin{verbatim} [ ' UNION ALL SELECT load_file('/etc/passwd'),null # ] \end{verbatim}

\begin{figure}[!h]
	\begin{center}
		\label{}
		\includegraphics[scale=\scaledvwa]{images/sql/sqli_low2.png}
		\caption{Récupération du fichier /etc/passwd via la commande load\_file : }
	\end{center}
\end{figure}




% ?id=a UNION SELECT password,last_name from users;-- -&Submit=Submit
% ?id=a %27UNION SELECT password,last_name from users#






\subsubsection{DVWA - Security level "Medium" et "High"}

Pour récupérer les mots de passe lorsque l'on règle le niveau de sécurité de DVWA sur "haut" et "medium", on utilise une combinaison des outils "Burp suite" et "sqlmap" fournis par kali linux. Le navigateur doit être configuré en utilisant ce proxy Burp suite, à savoir 127.0.0.1:8080. Cela permet l'interception des requêtes POST qui est alors copiée dans un fichier toto.txt utilisé ensuite dans la commande.

\begin{verbatim}
sqlmap -r ./toto.txt –dbs -D dvwa –dump all –os-shell
\end{verbatim}


\subsection{Contre-mesures}

Un certain nombre de règles permettent de se prémunir des attaques par injection de commandes SQL :
Pour se prémunir des injections SQL, on peut appliquer les principes suivants :
 \begin{itemize}[font=\color{magenta} \Large, label=\ding{43}]
	\item Vérifier le format des données saisies et notamment
	la présence de caractères spéciaux, 
	\item Éviter les comptes sans mot de passe,
	\item Ne pas afficher de messages d’erreur explicites affichant la requête ou une partie de la requête SQL,
	\item Supprimer les comptes utilisateurs non utilisés, notamment les comptes par défaut,
	\item Utiliser un firewall Applicatif de type mod\_security
    \item Désactiver l’option Load\_File.
\end{itemize}


Sur le plan pratique, un premier niveau de protection consiste à vouloir utiliser un outil comme mysqli\_real\_escape\_string() qui "échappe" les caractères indésirables : apostrophes, guillemets. Cette technique utilisée par DVWA - Medium level reste cependant vulnérable.

\begin{verbatim}
En effet, en utilisant l’HTTP URL Encoding, un espace devient 
un %20 dans l’URL, un  “!” devient un %21, une apostrophe %27, etc.
Cela nous permet donc ici de faire passer une guillemet ou une 
apostrophe de façon encodée pour ne pas qu’ils soient détectés 
et échappés par la fonction mysql_real_escape_string.
\end{verbatim}

Plus efficace est l'utilisation des "prepared statement". DVWA, level "impossible", utilise la classe \href{https://secure.php.net/manual/fr/class.pdostatement.php}{PDOStatment} pour préparer les requêtes et ainsi séparer le code des données.  


\begin{figure}[!h]
	\begin{center}
		\label{}
		\includegraphics[scale=0.6]{images/sql/sqli_impossible.png}
	\end{center}
\end{figure}








% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %



\section{Injection SQL aveugle}

\subsection{Description}

Les injections SQL aveugles, ou "blind SQL" en anglais, qu'on peut nommer BSQLi en abrégé,  sont des techniques utilisées lorsque le serveur n'est pas "bavard". Sur le plan du code PHP, il suffit de retirer la ligne de code suivante qui affiche dans une page html les erreurs SQL : 
\begin{verbatim}
or die('<pre>' . mysql_error() . '</pre>' );
\end{verbatim} 




\subsection{Exploitation}
Les attaques sur DVWA - level "low", se font progressivement. Elles nécessitent beaucoup plus de requêtes sur la base de donnée, ce qui pose un problème de discrétion pour l'attaquant. Une meilleure connaissance de SQL est aussi impérative. Ainsi, une attaque BSQLi manuelle effectuée sur le User ID de DVWA, visant à déterminer le nombre  de champs de la requête, en vue de faire une UNION, utilisera une injection "ORDER BY".

\begin{verbatim}
L'injection [ ' ORDER BY 1 # ], sans les crochets, ne renvoie rien,  par contre 
[ ' ORDER BY 3 # ] affiche "Unknown column '3' in 'order clause' ". 
La requête du script PHP utilise donc deux champs.
\end{verbatim} 

\begin{verbatim}
Ensuite, des injections [ ' UNION SELECT password, last_name FROM xxxx # ]
où xxxx désigne un nom de table évocant une liste d'utilisateurs ; on testera
utilisateurs, users, user, etc
\end{verbatim} 

\begin{verbatim}
Des injections [ ' UNION SELECT password, last_name FROM users 
WHERE LENGTH(password) = longeur # ] avec longueur = 1, 2, 3, ... 
vont permettre, itérativement, de connaître la taille du mot de passe.
\end{verbatim} 

\begin{verbatim}
Des injections [ ' UNION SELECT password, last_name FROM users 
WHERE LENGTH(password) = 8 AND SUBSTRING(password,1,1)='a' # ] 
testent si le mot de passe commence par "a".
\end{verbatim} 
\subsection{Contre-mesure}

On le voit ce type d'attaques peut devenir rapidement fastidieuses, voire impraticables. Une approche médiane consiste à écrire des scripts en python important des modules comme httplib et urllib.

Enfin, des produits sur étagères comme Burp suite/sqlmap ou, mieux,   \href{www.itsecteam.com}{havij} permettent de s'attaquer aux niveaux "Low", "Medium" "High" de manière plus efficace. Havij est cependant un outil windows ; Sous fedora 26, on doit installer une machine virtuelle windows ;  l'utilisation de wine est quant à elle souvent hasardeuse.
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %


\section{Attaques XSS }Reflected XSS

\subsection{Description}
 désignées au choix par les acronymes CSS ou XSS et qui seront
Un site web qui fournit d'une part un service de recueille d'informations via des formulaires et d'autre part un service de publication sur le site de ces mêmes informations
\subsection{Exploitation}

\subsection{Contre-mesure}


\section{Attaques XSS enregistrées }

\subsection{Description}

\subsection{Exploitation}

\subsection{Contre-mesure}


















%
%
%@ARTICLE{1056964,
%	author={A. Shamir},
%	journal={IEEE Transactions on Information Theory},
%	title={A polynomial-time algorithm for breaking the basic Merkle-Hellman cryptosystem},
%	year={1984},
%	volume={30},
%	number={5},
%	pages={699-704},
%	keywords={Cryptography;Computer science;Graphics;Mathematics;Microcomputers;Polynomials;Protection;Public key;Public key cryptography;Security;Testing},
%	doi={10.1109/TIT.1984.1056964},
%	ISSN={0018-9448},
%	month={Sep},}
%
%
%@BOOK{MARTIN2004,
%	title = {Codage, cryptologie et applications},
%	publisher = {Presses polytechniques et universitaires romandes},
%	year = {2014},
%	author = {Martin, Bruno}
%}
%
%@Book{GJ1979,
%	author = "Michael R. Garey and David S. Johnson",
%	title = "{Computers and Intractability, A Guide to the Theory of {NP}-Completeness}",
%	publisher = "W.H. Freeman and Company",
%	year = 1979,
%	address = "New York"
%}
%
%@book{opac,
%	title = "Handbook of Applied Cryptography",
%	author = "Alfred J. Menezes and Paul C. Van Oorschot and Scott A. Vanstone",
%	publisher = "CRC Press",
%	address = "Boca Raton, London, New York",
%	url = "http://opac.inria.fr/record=b1092394",
%	isbn = "0-8493-8523-7",
%	year = 1996,
%	note = {\url{http://cacr.uwaterloo.ca/hac/}}
%}
%
%@ARTICLE{DEROFF,
%	author={J. Deroff and R. Goyat},
%	title={Le problème du sac à dos en cryptographie},
%	year={2007},
%	note = {\url{http://j.deroff.free.fr/rapportter.pdf}}
%}
%
%@Book{stinson1996,
%	author =       {Stinson, Douglas},
%	title =        {{Cryptographie -- Théorie et pratique}},
%	publisher =    {International Thomson Publishing},
%	year =         {1996},
%	note =         {Traduction de Serge Vaudenay},
%}
%
%@ARTICLE{COSTER,
%	author={Coster, Matthijs J. and Joux, Antoine  and La Macchia, Brian A. and Odlyzko, Andrew M. and Schnorr, Claus-Peter and Stern, Jacques},
%	title={Improved low-density subset sum algorithms},
%	journal={computational complexity},
%	year={1992},
%	volume={2},
%	number={2},
%	pages={111-128},
%	mounth={June},
%	note = {\url{http://www.di.ens.fr/~fouque/ens-rennes/sac-LLL.pdf}}
%}
%
%@article{Merkle,
%	author = {Merkle, R. and Hellman, M.},
%	title = {Hiding Information and Signatures in Trapdoor Knapsacks},
%	journal = {IEEE Trans. Inf. Theor.},
%	issue_date = {1978},
%	volume = {24},
%	number = {5},
%	month = {Sep},
%	year = {1978},
%	issn = {0018-9448},
%	pages = {525--530},
%	numpages = {6},
%	url = {http://dx.doi.org/10.1109/TIT.1978.1055927},
%	doi = {10.1109/TIT.1978.1055927},
%	acmid = {2269393},
%	publisher = {IEEE Press},
%	address = {Piscataway, NJ, USA},
%} 
